-*- outline -*-

* Special forms

** lambda

(lambda lambda-list body)

body: a form

** (lambda-list)

A list of symbols or type expressions (see type-expr.txt).

** apply

(apply fun &rest args)

fun: a function, evaluated
args: arguments, each evaluated

** defun

(defun name lambda-list body)

name: a symbol
body: a form

** function

(function name)

name: a symbol

** defclass

(defclass name &rest member_names)

name: symbol
member_names: a list of symbols

*** Description

Creates a class, binds it in the global environment, and for each
member creates a getter generic function called ("." + member) and a
setter generic function called ("." + member + "-setter").

** def

(def name lambda-list body)

name: a symbol
body: a form

*** Description

Binds the method in the class' vtable and (re-)defines a generic
function with the given name, that calls the method.

The first parameter in the lambda list must be typed.

** new

(new class)

class: a form, evaluated

*** Description

Creates a new instance of a class

** set

(set place value)

place: a place (see places.txt)
value: a form, evaluated

** finally

(finally protected-form cleanup-form)

** throw

(throw exception)

exception: a form, evaluated

** with-handlers

(with-handlers handlers body)

handlers is a list of (class function) pairs

** call/ec, call-with-escape-continuation

(call/ec fun)

** bind

(bind bindings body)

** slot-value

(slot-value obj name)

obj: a form, evaluated
name: a symbol

** set-slot-value

(set-slot-value obj name value)

obj: a form, evaluated
name: a symbol
value: a form, evaluated

** native

(native str)

*** Description

Contains inline JavaScript code.  JavaScript code can escape back into
Lisp with ~(), e.g. ~((foo-bar x y)) and ~("hello world").

** defmacro 

(defmacro name args body)

args: a list of symbols; if the last symbol starts with the "@"
character, the argument is a splat argument, that will be bound to the
remaining subforms.

** quasiquote, `

Quasiquote is a convenient mechanism for writing code-generating
macros.  A quasiquote form holds a template with holes.

A classical example is the WHEN macro:

  (defmacro when (cond then)
    `(if ,cond ,then false))

which is equivalent to:

  (defmacro when (cond then)
    (quasiquote (if (unquote cond) (unquote then) false)))

QUASIQUOTE forms are turned by a preprocessing step into an expression
that, when evaluated, will produce the desired code.

So, the macro above is conceptually equivalent to:

  (defmacro when (cond then)
    (make-compound-form
      (make-form-list (make-symbol-form "if")
                      cond
                      then
                      (make-symbol-form "false"))))

When the WHEN macro is encountered in Lisp code, the macro's body is
evaluated with COND and THEN bound to the Lisp forms from the macro's
call site.  The macro's result form (the (IF ...)) is then compiled in
place of the original user code.

`x = the symbol X
`() = error
`,x = the value of X
`,@... = error

** unquote, ,

An UNQUOTE form represents a hole inside a QUASIQUOTE template.

** unquote-splicing, ,@

An UNQUOTE-SPLICING form represents a second kind of template hole,
whose contents evaluate to a list, and are spliced into the
surrounding compound form.

Let LIST be a list of forms (bar quux).

Then `(foo ,@q) produces (foo bar quux).

This is conceptually equivalent to:

(make-compound-form
  (append-form-lists
    (make-form-list (make-symbol-form "foo"))
    (make-form-list (make-symbol-form "foo")
                    (make-symbol-form "quux"))))
