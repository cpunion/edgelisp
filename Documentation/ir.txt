-*- outline -*-

* Intermediate Representation (IR)

** string

{ irt: "string", s: <<string>> }

*** Description

A literal string.

** lambda

{ irt: "lambda", req_params: <<req_param_names>>, body: <<body_ir>> }

req_param_names: an array of strings
body_ir: IR of the lambda's body

*** Description

First-class function abstraction.

** progn

{ irt: "progn", exprs: <<expr_irs>> }

*** Description

Evaluates multiple expressions in sequence.

** defvar

{ irt: "defvar", name: <<name>>, value: <<value_ir>> }

name: a symbol
value_ir: IR of the variable's value, evaluated

*** Description

Establishes a binding in the top level environment.

** defun

{ irt: "defun", name: <<name>>, lambda: <<lambda_ir>> }

name: a string
lambda_ir: IR for the function's body

*** Description

Registers a function in the global environment.

** flet

** function, #'

{ irt: "function", name: <<name>> }

name: the function name, a string

*** Description

Accesses the function binding with the given name, i.e. performs a
lookup in the function namespace.

#'foo is equivalent to (function foo).

** apply

{ irt: "apply", fun: <<fun_ir>>, args: <<arg_irs>> }

fun_ir: IR for function to call, evaluated
arg_irs: IRs for function arguments, each evaluated

*** Description

Calls a function supplied as a parameter.

** set-method

{ irt: "set-method", name: <<string>>, class: <<class_ir>>, lambda: <<lambda_ir>> }

*** Description

Binds a method in the class' vtable.

** make-class

{ irt: "make-class", name: <<string>>, members: <<member_names>> }

*** Description

Creates a class object.

** make-instance

{ irt: "make-instance", class: <<class_ir>> }

*** Description

Creates an instance of a class.

** invoke-method

{ irt: "invoke-method", name: <<string>>, params: <<param_irs>> }

** unwind-protect

{ irt: "unwind-protect", protected: <<protected_ir>>, cleanup: <<cleanup_ir>> }

** bind-handlers

{ irt: "bind-handlers", handlers: <<handlers>>, body: <<body_ir>> }

handlers is a non-empty list of { class: <<class_ir>>, function: <<fun_ir>> }

*** Description

Executes the body with exception handlers installed.  Each handler
consists of a class and a handler function.  The handler matches
exceptions that are instances of the handler class (or a subclass).

Each handler_function must evaluate to a function that takes two
arguments: an exception, and a next-handler function.  The handler has
three possibilities: (1) return a value; this will be the result of
the THROW that invoked the handler, (2) take a non-local exit, to
abort execution of the thrower, (3) decline handling by calling the
next-handler function.

** throw

{ irt: "throw", exception: <<exception_ir>> }

*** Description

Evaluates the exception and searches for an applicable handler.  If
one is found, the handler function is called as described at
BIND-HANDLERS.

** call-with-escape-continuation

{ irt: "call-with-escape-continuation", fun: <<fun_ir>> }

*** Description

Calls the function with one argument, an escape continuation.  The
continuation is a function that takes a single argument.

** set

{ irt: "set", name: <<string>>, value: <<value_ir>> }

** defmacro

** quasiquote, unquote, unquote-splicing

** if

** eval

** var

{ irt: "var", name: <<string>> }

*** Description

Accesses the value of the variable.

** bind

{ irt: "bind", bindings: <<bindings>>, body: <<body_ir>> }

bindings: a list of [name, value_ir] pairs
name: string

*** Description

Dynamically scoped rebinding of global variables.

** inline-js

** invoke-debugger
