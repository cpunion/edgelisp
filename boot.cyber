;;; -*- LISP -*-
;;;
;;; CyberLisp: A Lisp that compiles to JavaScript 1.5.
;;;   
;;; Copyright (C) 2008 by Manuel Simoni.
;;;   
;;; CyberLisp is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published
;;; by the Free Software Foundation; either version 2, or (at your
;;; option) any later version.
;;;   
;;; CyberLisp is distributed in the hope that it will be useful, but
;;; WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;;; General Public License for more details.
;;; 
;;; You should have received a copy of the GNU General Public License
;;; along with GNU Emacs; see the file COPYING.  If not, write to the
;;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
;;; Boston, MA 02110-1301, USA.

;;; (defmacro name sig &rest body)  [defmacro-form]
;;;  0        1    2         3
(set-expander defmacro
  (%%lambda (defmacro-form)
    `(set-expander ,(compound-elt defmacro-form 1)
       (%%lambda (%%form)
         (compound-apply
           (%%lambda ,(compound-elt defmacro-form 2)
             (progn
               ,@(compound-slice defmacro-form 3)))
           (compound-slice %%form 1))))))

(defmacro lambda (sig &rest body)
  `(%%lambda ,sig (progn ,@body)))

(defmacro defun (name sig &rest body)
  `(set-function ,name (lambda ,sig ,@body)))

(defmacro defvar (name value)
  `(unless (bound? ,name)
     (defparameter ,name ,value)))

(defmacro if (test consequent &opt (alternative `null))
  `(%%if ,test ,consequent ,alternative))

(defmacro when (test &rest consequent)
  `(if ,test (progn ,@consequent) null))

(defmacro unless (test &rest alternative)
  `(if ,test null (progn ,@alternative)))

(defmacro let (bindings &rest body)
  `(funcall (lambda ,(compound-map (lambda (b) 
                                     (compound-elt b 0))
                                   bindings)
              ,@body)
            ,@(compound-map (lambda (b) 
                              (compound-elt b 1)) 
                            bindings)))

(defmacro let* (bindings &rest body)
  `(funcall (lambda ,(compound-map (lambda (b) 
                                     (compound-elt b 0))
                                   bindings)
              ,@(compound-map (lambda (b) 
                                `(set ,(compound-elt b 0) ,(compound-elt b 1)))
                              bindings)
              ,@body)
            ,@(compound-map (lambda (b) 
                              `null)
                            bindings)))

(defun not (x)
  (if x false true))

(defmacro block (name &rest body)
  `(call-with-escape-function (lambda (,name) ,@body)))

(defmacro return-from (name value)
  `(funcall ,name ,value))

(defmacro unwind-protect (protected &rest cleanups)
  `(call-unwind-protected (lambda () ,protected)
                          (lambda () ,@cleanups)))

(defmacro catch (handler-specs &rest body)
  `(bind-handlers (list ,@(compound-map (lambda (handler-spec)
                                          `(list ,(compound-elt handler-spec 0)
                                                 ,(compound-elt handler-spec 1)))
                                        handler-specs))
                  (lambda () ,@body)))

(defun setter-name (getter-name)
  (string-concat getter-name "-setter"))

(defmacro set (place value)
  (if (symbol? place)
      `(%%set ,place ,value)
      `(,(string-to-symbol (setter-name (symbol-name (compound-elt place 0))))
        ,@(compound-slice place 1)
        ,value)))
      
(defmacro assert (test &opt (msg '"assertion failed"))
  `(let ((result ,test))
     (if result
         result
         (progn
           (print ,msg)
           (print ',test)))))

(defmacro assert-eq (a b)
  `(assert (eq ,a ,b)))

(defmacro defclass (name-and-super &opt (slots '()))
  (let ((class-name null)
        (superclass null))
    (if (symbol? name-and-super)
        (progn (set class-name name-and-super)
               (set superclass null))
        (progn (set class-name (compound-elt name-and-super 0))
               (set superclass (compound-elt name-and-super 1))))
    `(progn
       (when (not (bound? ,class-name)) 
         (set ,class-name (make-class)))
       ,(if superclass 
            `(set-superclass ,class-name ,superclass) 
            `null)
       ,@(compound-map (lambda (slot) (defclass-do-slot class-name slot)) 
                       slots)
       (defun ,class-name ()
         (make ,class-name))
       ,class-name)))

(defun defclass-do-slot (class-name slot)
  (let* ((slot-name (symbol-name slot))
         (slot-name-form (string-to-form slot-name))
         (getter-name (string-concat "." slot-name))
         (setter-name (setter-name getter-name)))
    `(progn
       (defmethod ,(string-to-symbol getter-name) ((obj ,class-name))
         (slot obj ,slot-name-form))
       (defmethod ,(string-to-symbol setter-name) ((obj ,class-name) value)
         (set-slot obj ,slot-name-form value)))))

(defun %%defmethod-param-type (param)
  (if (compound? param)
      (compound-elt param 1)
      (if (symbol? param)
          param
          (assert false))))

(defmacro defmethod (name params &rest body)
  (let ((class (%%defmethod-param-type (compound-elt params 0)))
        (name-string (string-to-form (symbol-name name))))
    `(progn
       (set-method ,class ,name-string (lambda ,params ,@body))
       (defgeneric ,name))))

(defmacro defgeneric (name &rest args)
  (let ((name-string (string-to-form (symbol-name name))))
    `(defun ,name (&rest args &all-keys keys)
       (let ((obj (list-elt args 0)))
         (apply (get-method obj ,name-string) args keys)))))

(defclass <object>)

(defclass <exception>)
(defclass (<error> <exception>))
(defclass (<warning> <exception>))
(defclass (<restart> <exception>))

(defmacro deferror (name &rest slots)
  `(defclass (,name <error>) ,@slots))

(deferror <failed-assertion>)

(defclass <dict>)

(defgeneric get (dict key &opt default))
(defgeneric put (dict key value))
(defgeneric has-key (dict key))

(defclass (<string-dict> <dict>))

(defmethod get ((dict <string-dict>) (key <string>) &opt default)
  (if (has-key dict key)
      (string-dict-get dict key)
      default))

(defmethod put (<string-dict> (key <string>) value)
  (string-dict-put string-dict key value))

(defmethod has-key (<string-dict> (key <string>))
  (string-dict-has-key string-dict key))
