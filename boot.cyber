;;; -*- LISP -*-
;;;
;;; CyberLisp: A Lisp that compiles to JavaScript 1.5.
;;;   
;;; Copyright (C) 2008 by Manuel Simoni.
;;;   
;;; CyberLisp is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published
;;; by the Free Software Foundation; either version 2, or (at your
;;; option) any later version.
;;;   
;;; CyberLisp is distributed in the hope that it will be useful, but
;;; WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;;; General Public License for more details.
;;; 
;;; You should have received a copy of the GNU General Public License
;;; along with GNU Emacs; see the file COPYING.  If not, write to the
;;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
;;; Boston, MA 02110-1301, USA.

;;; (defmacro name sig &rest body)  [defmacro-form]
;;;  0        1    2         3
(%%defmacro defmacro
  (%%lambda (defmacro-form)
    `(%%defmacro ,(%%compound-elt defmacro-form 1)
       (%%lambda (%%form)         
         (%%compound-apply            
           (%%lambda ,(%%compound-elt defmacro-form 2)             
             (%%progn               
               ,@(%%compound-slice defmacro-form 3)))           
           (%%compound-slice %%form 1))))))

(defmacro progn (&rest body)
  `(%%progn ,@body))

(defmacro lambda (sig &rest body)
  `(%%lambda ,sig (progn ,@body)))

(defmacro defun (name sig &rest body)
  `(%%defun ,name (lambda ,sig ,@body)))

(defmacro defparameter (name value)
  `(%%defparameter ,name ,value))

(defmacro boundp (name)
  `(%%boundp ,name))

(defmacro fboundp (name)
  `(%%fboundp ,name))

(defmacro defvar (name value)
  `(unless (boundp ,name)
     (defparameter ,name ,value)))

;; Note that in contrast to other Lisps, CyberLisp does not allow
;; mixing of runtime values and forms, so the alternative's default
;; value cannot simply be the value `null', it has to be the form
;; `null'.
(defmacro if (test consequent &opt (alternative `null))
  `(%%if ,test ,consequent ,alternative))

(defmacro when (test &rest consequent)
  `(if ,test (progn ,@consequent) null))

(defmacro unless (test &rest alternative)
  `(if ,test null (progn ,@alternative)))

(defmacro set (name value)
  `(%%set ,name ,value))

(defun compound-map (fun compound)
  (%%compound-map fun compound))

(defun compound-elt (compound i)
  (%%compound-elt compound i))

(defun compound-slice (compound start)
  (%%compound-slice compound start))

(defmacro let (bindings &rest body)
  `(%%funcall (lambda ,(compound-map (lambda (b) 
                                       (compound-elt b 0))
                                     bindings)
                ,@body)
              ,@(compound-map (lambda (b) 
                                (compound-elt b 1)) 
                              bindings)))

(defun macroexpand-1 (form)
  (%%macroexpand-1 form))

(defun print (object)
  (%%print object))

(defun eq (a b)
  (%%eq a b))

(defun not (x)
  (if x false true))

(defun symbol-name (symbol)
  (%%symbol-name symbol))

(defun symbolp (form)
  (%%symbolp form))

(defun compoundp (form)
  (%%compoundp form))

(defun make-class ()
  (%%make-class))

(defun set-super-class (class super-class)
  (%%set-super-class class super-class))

(defun make (class)
  (%%make class))

(defun typeof (obj)
  (%%typeof obj))

(defun subtypep (type-1 type-2)
  (%%subtypep type-1 type-2))

(defmacro defclass (name &rest slots)
  (let ((name (if (symbolp name) name (compound-elt name 0)))
        (super-class (if (symbolp name) null (compound-elt name 1))))
    `(progn
       (unless (boundp ,name)
         (set ,name (make-class)))
       ,(if super-class
            `(set-super-class ,name ,super-class)
            `null))))

(defmacro list (&rest args)
  `(%%list ,@args))

(defmacro catch (handler-specs &rest body)
  `(%%catch (list ,@(compound-map (lambda (handler-spec)
                                    `(list ,(compound-elt handler-spec 0)
                                           ,(compound-elt handler-spec 1)))
                                  handler-specs))
            (lambda () ,@body)))

(defun throw (exception)
  (%%throw exception))

(defclass <exception>)
(defclass (<error> <exception>))
(defclass (<warning> <exception>))
(defclass (<restart> <exception>))

(defclass (<failed-assertion> <error>))

(defmacro assert (test)
  `(unless ,test
     (throw (make <failed-assertion>))))

(defmacro assert-eq (a b)
  `(assert (eq ,a ,b)))

