;; -*- LISP -*-

(assert-eq (progn 1 2 3) 3)
(assert-eq (progn 1) 1)
(assert-eq (progn) null)

(assert-eq (%%funcall (lambda ())) null)
(assert-eq (%%funcall (lambda () 1)) 1)
(assert-eq (%%funcall (lambda (x) x) 1) 1)
(assert-eq (%%funcall (lambda (x &opt (y x)) y) 1) 1)

(defun test-x () 117)
(assert-eq (test-x) 117)

(defun test-y (y) y)
(assert-eq (test-y 133) 133)

;; Exceptions

(defclass (<my-error> <error>))
(defclass (<your-error> <error>))

(defvar test-counter 0)
(catch ((<my-error> (lambda (e next-handler)
                      (set test-counter 1))))
  (throw (make <my-error>)))
(assert-eq test-counter 1)

(set test-counter 0)
(catch ((<your-error> (lambda (e next-handler)
                        (set test-counter 2))))
  (catch ((<my-error> (lambda (e next-handler)
                        (set test-counter 1))))
    (throw (make <your-error>))))
(assert-eq test-counter 2)

(set test-counter 0)
(catch ((<your-error> (lambda (e next-handler)
                        (set test-counter 2)))
        (<my-error> (lambda (e next-handler)
                      (set test-counter 1))))
  (throw (make <your-error>)))
(assert-eq test-counter 2)

(set test-counter 0)
(catch ((<your-error> (lambda (e next-handler)
                        (set test-counter 2)))
        (<my-error> (lambda (e next-handler)
                      (set test-counter 1))))
  (throw (make <my-error>)))
(assert-eq test-counter 1)

(set test-counter 0)
(catch ((<my-error> (lambda (e next-handler)
                      (set test-counter 1))))
  (catch ((<your-error> (lambda (e next-handler)
                          (set test-counter 2)))
          (<my-error> (lambda (e next-handler)
                        (%%funcall next-handler))))
    (throw (make <my-error>))))
(assert-eq test-counter 1)

(set test-counter 0)
(catch ((<my-error> (lambda (e next-handler)
                      (assert-eq test-counter 3))))
  (catch ((<your-error> (lambda (e next-handler)
                          (set test-counter 2)))
          (<my-error> (lambda (e next-handler)
                        (set test-counter 3)
                        (%%funcall next-handler))))
    (throw (make <my-error>))))
(assert-eq test-counter 3)


;; #' syntax

(defun foo () 12)
(assert #'foo)
(assert-eq #'foo (%%function foo))
(assert-eq (%%funcall #'foo) 12)

;; Escape functions

(assert-eq 1 (block x (return-from x 1)))
(assert-eq 1 (block x (block y (return-from x 1))))
(assert-eq 2 (block x (block y 2)))
(assert-eq 3 (block x (block y 2) 3))
(assert-eq 3 (block x (block y (return-from y 4)) 3))
(assert-eq 4 (block x (block y (return-from y 4))))

(defun jumper (exit) 
  (return-from exit 33))
(assert-eq 33 (block outer (jumper outer)))

;; Unwind protect

(defclass (<another-error> <error>))

(defvar unwind-ct 0)
(catch ((<another-error> (lambda (e next-handler))))
  (unwind-protect (throw (make <another-error>))
    (set unwind-ct 1)))
(assert-eq unwind-ct 1)

(set unwind-ct 0)
(assert-eq 2 (unwind-protect 2
               (set unwind-ct 1)))
(assert-eq unwind-ct 1)

(set unwind-ct 0)
(assert-eq 12 (block exit
                (unwind-protect (return-from exit 12)
                  (set unwind-ct 1))))
(assert-eq unwind-ct 1)

;; Slots

(defclass <foo>)
(defvar foo (make <foo>))
(assert-eq (slot-value foo "slot1") null)
(assert-eq (slot-value foo "slot2") null)
(set-slot-value foo "slot1" 1)
(assert-eq (slot-value foo "slot1") 1)
(assert-eq (slot-value foo "slot2") null)
(set-slot-value foo "slot1" null)
(assert-eq (slot-value foo "slot1") null)
(assert-eq (slot-value foo "slot2") null)

;; Methods

(defvar <c> (make-class))
(set-method <c> "m1" (lambda (c x) x))
(defvar c (make <c>))
(defun m1 (c x)
  (%%invoke-method m1))
(assert-eq (m1 c 12) 12)
